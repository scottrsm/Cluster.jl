<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cluster.jl Documentation · Cluster</title><meta name="title" content="Cluster.jl Documentation · Cluster"/><meta property="og:title" content="Cluster.jl Documentation · Cluster"/><meta property="twitter:title" content="Cluster.jl Documentation · Cluster"/><meta name="description" content="Documentation for Cluster."/><meta property="og:description" content="Documentation for Cluster."/><meta property="twitter:description" content="Documentation for Cluster."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Cluster</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Cluster.jl Documentation</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Metric-Definitions:"><span>Metric Definitions:</span></a></li><li><a class="tocitem" href="#What-is-the-best-cluster-number?"><span>What is the best cluster number?</span></a></li><li><a class="tocitem" href="#Cluster-Functions"><span>Cluster Functions</span></a></li><li><a class="tocitem" href="#Metric-Functions"><span>Metric Functions</span></a></li><li><a class="tocitem" href="#Fit-Metric-Functions"><span>Fit Metric Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Cluster.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cluster.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/scottrsm/Cluster.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/scottrsm/Cluster.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Cluster.jl-Documentation"><a class="docs-heading-anchor" href="#Cluster.jl-Documentation">Cluster.jl Documentation</a><a id="Cluster.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster.jl-Documentation" title="Permalink"></a></h1><h1 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h1><p>This module contains functions to determine natural clusters using unsupervised learning. A point of interest in this module over other libraries is the rich set of <em>metrics</em>  that one can use with K-means clustering.  Additionally, some of the metrics may be weighted which can be used to help alleviate   <strong>K-means</strong> attraction to spherical clusters.</p><p>This module also has the functionality to determine the <strong>cluster size</strong> of a data set.</p><p>Cluster functions (from lowest to highest level):</p><ul><li><p><code>kmeans_cluster</code>: Given a cluster number and metric, determine clusters. </p><ul><li>This clustering algorithm can use any of the metrics:    <code>L2</code> (<span>$L_2$</span> – default), <code>LP</code> (<span>$L_p$</span>), <code>LI</code> (<span>$L_\infty$</span>), <code>KL</code> (Kullback-Leibler), <code>CD</code> (Cosine Distance), and <code>JD</code> (Jaccard Distance).</li><li>In the case of <code>L2</code> and <code>CD</code>, the metrics allow for weighted distances represented as a positive definite matrix.</li></ul></li><li><p><code>find_best_info_for_ks</code>: Given a metric and a range of cluster numbers, determine clusters and gather fitness data for each cluster.</p><ul><li>This function uses the functions:<ul><li>kmeans_cluster.</li></ul></li></ul></li><li><p><code>find_best_cluster</code>: Given a metric, find the best cluster number and determine the clusters. </p><ul><li>This function uses the functions:<ul><li><code>kmeans_cluster</code></li><li><code>find_best_info_for_ks</code></li></ul></li></ul></li><li><p><code>find_cluster_map</code>: Takes clusters and a <code>discrete</code> attribute of the data set and maps cluster numbers to attribute values.</p></li><li><p><code>confusion_matrix</code>: Computes the confusion matrix – comparing actual against predicted values.</p></li></ul><h2 id="Metric-Definitions:"><a class="docs-heading-anchor" href="#Metric-Definitions:">Metric Definitions:</a><a id="Metric-Definitions:-1"></a><a class="docs-heading-anchor-permalink" href="#Metric-Definitions:" title="Permalink"></a></h2><p>Given <code>N</code> vectors, <span>${\bf x}, {\bf y}$</span> :</p><ul><li><code>L2</code>: The standard <span>$L_2$</span> norm: <span>${\rm L2}({\bf x}, {\bf y}) = \sqrt{\sum_{i=1}^N (x_i - y_i)^2}$</span><ul><li>With a symmetric, positive semi-definite weight matrix <code>W</code>   this becomes: <span>${\rm L2}({\bf x}, {\bf y}, \hbox{M=W}) = \sqrt{{\bf x} {\boldsymbol \cdot} (M {\bf y})}$</span></li></ul></li><li><code>LP</code>: The standard <span>$L_p$</span> norm: <span>${\rm LP}({\bf x}, {\bf y}, p) = \left(\sum_{i=1}^N |x_i - y_i|^p)\right)^{\frac{1}{p}}$</span><ul><li><strong>Note:</strong> To use this metric with <code>find_best_cluster</code> for a given value of <code>p</code>,    you will need to pass the closure, <code>(x,y; kwargs...) -&gt; LP(x,y, p; kwargs...)</code>,   to the keyword parameter <code>dmetric</code>.</li></ul></li><li><code>LI</code>: The standard <span>$L_\infty$</span> norm: <span>${\rm LI}({\bf x}, {\bf y}) = \mathop{\rm max}_{i \in [1,N]}\limits |x_i - y_i|$</span> </li><li><code>KL</code>: A symmetrized Kullback-Leibler divergence: <span>${\rm KL}({\bf x}, {\bf y}) = \sum_{i=1}^N x_i \log(x_i/y_i) + y_i \log(y_i/x_i)$</span></li><li><code>CD</code>: The &quot;cosine&quot; distance: <span>${\rm CD}({\bf x}, {\bf y}) = 1 - {\bf x} {\boldsymbol \cdot} {\bf y} / (\|{\bf x}\|  \|{\bf y}\|)$</span><ul><li>With a symmetric <em>strictly</em> positive definite weight matrix <code>W</code> this becomes:    <span>$\\ {\rm CD}({\bf x}, {\bf y}, \hbox{M=W}) = 1 - {\bf x} {\boldsymbol \cdot} \left( M {\bf y}\right) / (|\!|\!|{\bf x}|\!|\!|  |\!|\!|{\bf y}|\!|\!|)$</span> <ul><li>Here: <span>$|\!|\!| {\bf z} |\!|\!| = \sqrt{{\bf z} {\boldsymbol \cdot} \left( M {\bf z}\right)}$</span></li></ul></li></ul></li><li><code>JD</code>: The Jaccard distance.</li></ul><h2 id="What-is-the-best-cluster-number?"><a class="docs-heading-anchor" href="#What-is-the-best-cluster-number?">What is the best cluster number?</a><a id="What-is-the-best-cluster-number?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-the-best-cluster-number?" title="Permalink"></a></h2><p>The function <code>find_best_cluster</code> attempts to find the best cluster number. To do this, it monitors the total variation as one increases the cluster number. The total variation goes  down (generally) as we find (potentially locally) optimal solutions for each cluster number. If we pick a cluster number using only the total variation, we will miss the &quot;natural cluster&quot; number.</p><p>To avoid this, we adjust the total variation by a function that depends on the dimension of the space we are working in as well as the cluster number. The reasoning follows:</p><p>The idea is to look at the natural rate at which the total variation decreases with cluster number when  there are no clusters. In this way we can adjust the total variation to take into account  this &quot;ambient&quot; decay.</p><p>To do this, we start by assuming that the data is uniformly distributed in our domain  (with respect to the metric used) when given the data: <code>k</code> clusters; <code>m</code> points; the domain in <code>n</code> dimensions. We assume that the <code>k</code> clusters have the same number of points and fill a sphere  of radius, <code>R</code>. This means that <span>$R^n \approx k \, r_k^n$</span>.</p><p>Solving for <span>$r_k$</span> we have <span>${r_k=R\\\left(\\\frac{1}{k}\\\right)^{\\\frac{1}{n}}}$</span>. The total variation of <code>k</code> clusters is then roughly: <span>${k \\\, r_k\\\left(\\\frac{m}{k}\\\right)}$</span>.  This becomes: <span>$\\\frac{m R}{k^{\\\frac{1}{n}}}$</span>. Thus, even in the absence of any true clusters, the total variation decays like <span>$k^{\\\frac{1}{n}}$</span>.</p><p>The function <code>find_best_cluster</code> compares the total variation of cluster numbers in a range. It chooses the cluster number, <code>k</code>, with the largest relative <em>rate</em>  of decrease (with respect to cluster size) in adjusted total variation. The adjusted variation modifies the total variation for each <code>k</code> by the multiplicative factor  <span>$k^{\\\frac{1}{n}}$</span>.  The variation is further adjusted by the  fraction of unused cluster centroids. Finally, before computing the relative rate of variation decrease, the  series is further adjusted to be monotonically non-increasing.</p><p><strong>NOTE:</strong> This analysis may not be as useful if the &quot;natural&quot; clusters (or a substantial subset)  lie in some lower dimensional hyperplane in the ambient space.</p><h2 id="Cluster-Functions"><a class="docs-heading-anchor" href="#Cluster-Functions">Cluster Functions</a><a id="Cluster-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.kmeans_cluster-Union{Tuple{Matrix{T}}, Tuple{F}, Tuple{T}, Tuple{Matrix{T}, Int64}} where {T&lt;:AbstractFloat, F&lt;:Function}" href="#Cluster.kmeans_cluster-Union{Tuple{Matrix{T}}, Tuple{F}, Tuple{T}, Tuple{Matrix{T}, Int64}} where {T&lt;:AbstractFloat, F&lt;:Function}"><code>Cluster.kmeans_cluster</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kmeans_cluster(X, k=3[; dmetric, threshold, W=nothing, N=1000, seed=0, check_W=false])</code></pre><p>Groups a set of points into <code>k</code> clusters based on the distance metric, <code>dmetric</code>.</p><p><strong>Type Constraints</strong></p><ul><li><code>T &lt;: AbstractFloat</code></li><li><code>F &lt;: Function</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>X::Matrix{T}</code>   : (n,m) Matrix representing <code>m</code> points of dimension <code>n</code>.</li><li><code>k::Int=3</code>       : The number of clusters to form.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dmetric::F=L2</code>  : The distance metric to use.</li><li><code>threshold::Float=1.0e-2</code>  : The relative error improvement threshold (using total variation)</li><li><code>W::Union{Nothing, AbstractMatrix{T}}=nothing</code> : Optional <code>(nxn)</code> weight matrix for metric.</li><li><code>N::Int=1000</code>    : The maximum number of iterations to try.</li><li><code>seed::Int=0</code>    : If <code>seed</code> &gt; 0, create a random number generator to use for initial clustering.</li><li><code>check_W::Bool=false</code>: If <code>check_W</code>, check that the matrix, <code>W</code>, is strictly positive definite.</li></ul><p><strong>Input Contract</strong></p><ul><li><span>$W = {\rm nothing} ∨ \left( ({\rm typeof}(W) = {\rm Matrix}\{T\}) ∧ W \in {\boldsymbol S}_{++}^{n} \right)$</span></li><li><span>$1 \le k \le m$</span></li><li><code>N &gt; 0</code></li><li><code>threshold &gt; 0.0</code></li><li><code>dmetric &lt;: Function</code></li></ul><p><strong>Return</strong></p><p>A Tuple:</p><ul><li><code>Dict{Int, Int}</code>  : Mapping of points (<code>n</code>-vectors) indices to centroid indices.</li><li><code>Matrix{T}</code>       : (nxk) Matrix representing <code>k</code> centroids of <code>n</code>-vectors.</li><li><code>Float64</code>         : The total variation between points and their centroids (using <code>dmetric</code>).</li><li><code>Vector{Int}</code>     : Unused centroids (by index).</li><li><code>Int</code>             : The number of iterations to use for the algorithm to complete.</li><li><code>Bool</code>            : Did algorithm converge.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Cluster.jl#L25-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.find_best_info_for_ks-Union{Tuple{F}, Tuple{T}, Tuple{Matrix{T}, UnitRange{Int64}}} where {T&lt;:AbstractFloat, F&lt;:Function}" href="#Cluster.find_best_info_for_ks-Union{Tuple{F}, Tuple{T}, Tuple{Matrix{T}, UnitRange{Int64}}} where {T&lt;:AbstractFloat, F&lt;:Function}"><code>Cluster.find_best_info_for_ks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_best_info_for_ks(X, kRng[; dmetric=L2, threshold=1.0e-3, W=nothing, N=1000, num_trials=100, seed=1)</code></pre><p>Groups a set of <code>m</code> points (<code>n</code>-vectors) as an (nxm) matrix, <code>X</code>, into <code>k</code> clusters where <code>k</code> is in the range, <code>kRng</code>. The groupings are determined based on the distance metric, <code>dmetric</code>.</p><p><strong>Type Constraints</strong></p><ul><li><code>T &lt;: AbstractFloat</code></li><li><code>F &lt;: Function</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>X::Matrix{T}</code>           : (n,m) Matrix representing <code>m</code> points of dimension <code>n</code>.</li><li><code>kRng::UnitRange{Int}</code>   : The number of clusters to form.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dmetric::F=L2</code>          : The distance metric to use.</li><li><code>threshold::Float=1.0e-2</code>: The relative error improvement threshold (using total variation)</li><li><code>W::Union{Nothing, AbstractMatrix{T}}=nothing</code> : Optional Weight matrix for metric.</li><li><code>N::Int=1000</code>            : The maximum number of kmeans_clustering iterations to try for each cluster number.</li><li><code>num_trials::Int=300</code>    : The number of times to run kmeans_clustering for a given cluster number. </li><li><code>seed::Int=1</code>            : The random seed to use. (Used by kmeans_cluster to do initial clustering.)</li></ul><p><strong>Input Contract</strong></p><ul><li><span>$W = {\rm nothing} ∨ \left( ({\rm typeof}(W) = {\rm Matrix}\{T\}) ∧ W \in {\boldsymbol S}_{++}^{n} \right)$</span></li><li><span>$N &gt; 0$</span></li><li><span>$∀ i \in {\rm kRng}, i \ge 1$</span></li><li><code>threshold &gt; 0.0</code></li></ul><p><strong>Return</strong></p><p>A Tuple with entries:</p><ul><li><code>OrderedDict{Int, Float}</code>         : 1:k -&gt; The Total Variation for each cluster number.</li><li><code>OrderedDict{Int, Vector{Int}}</code>   : 1:k -&gt; Mapping of index of points (n-vectors in <code>X</code>) to centroid indices.</li><li><code>OrderedDict{Int, Matrix{T}}</code>     : 1:k -&gt; (nxk) Matrix representing <code>k</code> <code>n</code>-vector centroids.</li><li><code>OrderedDict{Int, Vector{In64}}</code>  : 1:k -&gt; Vector of unused centroids by index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Cluster.jl#L208-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.find_best_cluster-Union{Tuple{F}, Tuple{T}, Tuple{Matrix{T}, UnitRange{Int64}}} where {T&lt;:AbstractFloat, F&lt;:Function}" href="#Cluster.find_best_cluster-Union{Tuple{F}, Tuple{T}, Tuple{Matrix{T}, UnitRange{Int64}}} where {T&lt;:AbstractFloat, F&lt;:Function}"><code>Cluster.find_best_cluster</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_best_cluster(X, kRng[; dmetric=L2, threshold=1.0e-3, W=nothing, N=1000, num_trials=300, seed=1, verbose=false])</code></pre><p>Groups a set of points into the &quot;best&quot; number of clusters based on the distance metric, <code>dmetric</code>. It does this by examining the total variation between the points and the centroids for groups of <code>k</code> where <code>k</code> is in the range, <code>kRng</code>. </p><p><strong>NOTE:</strong> If the value <code>k</code> was determined to be the best cluster number but some of the centroids were not used, then the value of <code>k</code> will be set to the number of centroids that are used and the centroids that were not used will be removed. In this case it may be that the returned value of <code>k</code> is less that any value in the cluster range, <code>kRng</code>.</p><p><strong>Type Constraints</strong></p><ul><li><code>T &lt;: AbstractFloat</code></li><li><code>F &lt;: Function</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>X::Matrix{T}</code>           : (n,m) Matrix representing <code>m</code> points of dimension <code>n</code>.</li><li><code>kRng::UnitRange{Int}</code>   : The range of potential cluster values to try.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dmetric::F=L2</code>          : The distance metric to use.</li><li><code>threshold::Float=1.0e-2</code>: The relative error improvement threshold (using total variation)</li><li><code>W::Union{Nothing, AbstractMatrix{T}}=nothing</code> : Optional Weight matrix for metric.</li><li><code>N::Int=1000</code>            : The maximum number of kmeans_clustering iterations to try for each cluster number.</li><li><code>num_trials::Int=300</code>    : The number of times to run kmeans_clustering for a given cluster number. </li><li><code>seed::Int=1</code>            : The random seed to use. (Used by kmeans_cluster to do initial clustering.)</li><li><code>verbose::Bool=false</code>    : If <code>true</code>, print diagnostic information.</li></ul><p><strong>Input Contract</strong></p><ul><li><span>$W = {\rm nothing} ∨ \left( ({\rm typeof}(W) = {\rm Matrix}\{T\}) ∧ W \in {\boldsymbol S}_{++}^{n} \right)$</span></li><li><code>N &gt; 0</code></li><li><span>$∀ i \in {\rm kRng}, i \ge 1$</span></li><li><code>threshold &gt; 0.0</code></li></ul><p><strong>Return</strong></p><p>A Tuple:</p><ul><li><code>Int</code>           : The &quot;best&quot; cluster number, <code>k</code>.</li><li><code>Dict{Int, Int}</code>: Mapping of points (<code>n</code>-vectors) indices to centroid indices.</li><li><code>Matrix{T}</code>     : Cluster centroids, represented as an <code>(n,k)</code> matrix.</li><li><code>Float64</code>       : The total variation between points and their centroids (using <code>dmetric</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Cluster.jl#L314-L355">source</a></section></article><h2 id="Metric-Functions"><a class="docs-heading-anchor" href="#Metric-Functions">Metric Functions</a><a id="Metric-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Metric-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.Metrics.L2-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#Cluster.Metrics.L2-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>Cluster.Metrics.L2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L2(x,y[; M=nothing])</code></pre><p>Computes the <span>$L_2$</span> distance between two vectors. One of the features that may be different from other packages is the use of weighted metrics in some instances.</p><p><strong>Type Constraints</strong></p><ul><li><code>T &lt;: Real</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> : A numeric vector.</li><li><code>y::AbstractVector{T}</code> : A numeric vector.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>C::Union{Nothing, Matrix{T}</code> : Optional Weight matrix.</li></ul><p><strong>Input Contract (Low level function – Input contract not checked)</strong></p><ul><li><span>$|{\bf x}| = |{\bf y}|$</span></li><li><span>$M = {\rm nothing} \vee \left( ({\rm typeof}(M) = {\rm Matrix}\{T\}) \wedge M \in {\boldsymbol S}_{++}^{|{\bf x}|} \right)$</span></li></ul><p><strong>Return</strong></p><p><span>$L_2$</span> (optionally weighted) distance measure between the two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Metrics.jl#L12-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.Metrics.LP-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64}} where T&lt;:Real" href="#Cluster.Metrics.LP-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64}} where T&lt;:Real"><code>Cluster.Metrics.LP</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LP(x,y,p)</code></pre><p>Computes the <span>$L_p$</span> distance between two vectors.</p><p><strong>Type Constraints</strong></p><ul><li><code>T &lt;: Real</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> : A numeric vector.</li><li><code>y::AbstractVector{T}</code> : A numeric vector.</li><li><code>p::Int</code>               : The power of the norm.</li></ul><p><strong>Input Contract (Low level function – Input contract not checked)</strong></p><ul><li><span>$|{\bf x}| = |{\bf y}|$</span></li><li><code>p &gt; 0</code></li></ul><p><strong>Return</strong></p><p><span>$L_p$</span> distance measure between the two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Metrics.jl#L48-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.Metrics.LI-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#Cluster.Metrics.LI-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>Cluster.Metrics.LI</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LI(x,y)</code></pre><p>Computes the <span>$L_\infty$</span> distance between two vectors.</p><p><strong>Type Constraints</strong></p><ul><li><code>T &lt;: Real</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> : A numeric vector.</li><li><code>y::AbstractVector{T}</code> : A numeric vector.</li></ul><p><strong>Input Contract (Low level function – Input contract not checked)</strong></p><ul><li><span>$|{\bf x}| = |{\bf y}|$</span></li></ul><p><strong>Return</strong></p><p><span>$L_\infty$</span> distance measure between the two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Metrics.jl#L75-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.Metrics.KL-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#Cluster.Metrics.KL-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>Cluster.Metrics.KL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KL(x,y)</code></pre><p>Computes the <span>$Kullback-Leibler$</span> distance between two vectors.</p><p><strong>Type Constraints</strong></p><ul><li><code>T &lt;: Real</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> : A numeric vector.</li><li><code>y::AbstractVector{T}</code> : A numeric vector.</li></ul><p><strong>Input Contract (Low level function – Input contract not checked)</strong></p><p>Let <span>$N = |{\bf x}|$</span>.</p><ul><li><span>$|{\bf x}| = |{\bf y}|$</span></li><li><span>$\forall i \in [1, N]: x_i \ge 0$</span></li><li><span>$\forall i \in [1, N]: y_i \ge 0$</span></li><li><span>$\sum_{i=1}^N x_i = 1$</span></li><li><span>$\sum_{i=1}^N y_i = 1$</span></li></ul><p><strong>Return</strong></p><p><code>KL</code> distance measure between the two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Metrics.jl#L127-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.Metrics.CD-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#Cluster.Metrics.CD-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>Cluster.Metrics.CD</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CD(x,y[; M=nothing])</code></pre><p>Computes the &quot;cosine&quot; distance between two vectors.</p><p><strong>Type Constraints</strong></p><ul><li><code>T &lt;: Real</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> : A numeric vector.</li><li><code>y::AbstractVector{T}</code> : A numeric vector.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>M::Union{Nothing, Matrix{T}</code> : Optional Weight matrix.</li></ul><p><strong>Input Contract (Low level function – Input contract not checked)</strong></p><ul><li><span>$|{\bf x}| = |{\bf y}|$</span></li><li><span>$M = {\rm nothing} \vee \left( ({\rm typeof}(M) = {\rm Matrix}\{T\}) \wedge M \in {\boldsymbol S}_{++}^{|{\bf x}|} \right)$</span></li></ul><p><strong>Return</strong></p><p>Cosine distance measure between the two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Metrics.jl#L161-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.Metrics.JD-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#Cluster.Metrics.JD-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>Cluster.Metrics.JD</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JD(x,y)</code></pre><p>Computes the <code>Jaccard</code> metric between two vectors of a &quot;discrete&quot; type. For instance, the vectors could be integers; however, they can  also be of non-numeric type. The metric can also be used with  floating point values but, in that case, it may be more useful  to round/truncate to a particular &quot;block&quot; size.</p><p>If both <code>x</code> and <code>y</code> are vectors of zero length, a distance of <span>$0$</span> is returned.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> : A numeric vector.</li><li><code>y::AbstractVector{T}</code> : A numeric vector.</li></ul><p><strong>Return</strong></p><p><code>Jaccard</code> distance measure between the two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Metrics.jl#L100-L117">source</a></section></article><h2 id="Fit-Metric-Functions"><a class="docs-heading-anchor" href="#Fit-Metric-Functions">Fit Metric Functions</a><a id="Fit-Metric-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-Metric-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.Metrics.raw_confusion_matrix-Union{Tuple{P}, Tuple{A}, Tuple{AbstractVector{A}, AbstractVector{P}}} where {A, P}" href="#Cluster.Metrics.raw_confusion_matrix-Union{Tuple{P}, Tuple{A}, Tuple{AbstractVector{A}, AbstractVector{P}}} where {A, P}"><code>Cluster.Metrics.raw_confusion_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">raw_confusion_matrix(act, pred)</code></pre><p>Computes a confusion matrix of the discrete variables, <code>act</code> and <code>pred</code>. There are no row or column labels for this matrix.</p><p><strong>Type Constraints:</strong></p><ul><li>Expects types, <code>A</code> and <code>P</code> to have discrete values.</li></ul><p><strong>Arguments</strong></p><ul><li><code>act ::AbstractVector{A}</code> : A vector of the actual target values.</li><li><code>pred::AbstractVector{P}</code> : A vector of the predicted target values.</li></ul><p><strong>Input Contract:</strong></p><ul><li>|act| = |pred|</li></ul><p><strong>Return</strong></p><p>Tuple{Vector{A}, Vector{P}, Matrix{Int}}: A 3-tuple consisting of:</p><ul><li>Vector of unique values of <code>act</code>.  (Sorted from lowest to highest, otherwise the order returned from the function <code>unique</code>.)</li><li>Vector of unique values of <code>pred</code>. (Sorted from lowest to highest, otherwise the order returned from the function <code>unique</code>.)</li><li>A matrix of counts for all pairings of discrete values of <code>act</code> with <code>pred</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Metrics.jl#L222-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.Metrics.confusion_matrix-Union{Tuple{P}, Tuple{A}, Tuple{AbstractVector{A}, AbstractVector{P}}} where {A, P}" href="#Cluster.Metrics.confusion_matrix-Union{Tuple{P}, Tuple{A}, Tuple{AbstractVector{A}, AbstractVector{P}}} where {A, P}"><code>Cluster.Metrics.confusion_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">confusion_matrix(act, pred)</code></pre><p>Computes the confusion matrix of the <em>discrete</em> variables, <code>act</code> and <code>pred</code>.</p><p><strong>Type Constraints:</strong></p><ul><li>Expects types, <code>A</code> and <code>P</code> to have discrete values.</li></ul><p><strong>Arguments</strong></p><ul><li><code>act ::AbstractVector{A}</code> : A vector of the actual target values.</li><li><code>pred::AbstractVector{P}</code> : A prediction vector for the target.</li></ul><p><strong>Input Contract:</strong></p><ul><li>|act| = |pred|</li></ul><p><strong>Return</strong></p><p>Matrix{Any}:</p><ul><li>The raw confusion matrix augmented by a column on the left listing  all <em>actual</em> values (in sorted order if sortable) and  augmented on top with a row listing  all <em>predicted</em> values (in sorted order if sortable).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Metrics.jl#L298-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.Metrics.find_cluster_map-Union{Tuple{V}, Tuple{A}, Tuple{AbstractVector{V}, AbstractVector{A}}} where {A, V}" href="#Cluster.Metrics.find_cluster_map-Union{Tuple{V}, Tuple{A}, Tuple{AbstractVector{V}, AbstractVector{A}}} where {A, V}"><code>Cluster.Metrics.find_cluster_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_cluster_map(vals, attrs)</code></pre><p>This function finds the best map between the alues <code>vals</code> and a target  attribute, <code>attrs</code>. Both, <code>vals</code> and <code>attrs</code> are <em>assumed</em> to have  discrete values.</p><p><strong>Arguments</strong></p><ul><li>vals::AbstractVector{V}  – The input values.</li><li>attrs::AbstractVector{A} – The attribute values.</li></ul><p><strong>Return</strong></p><p>::Dict{V, A} – The map between the values and the attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Metrics.jl#L342-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.Metrics.predict-Union{Tuple{A}, Tuple{Matrix{Float64}, Matrix{Float64}, Dict{Int64, A}}} where A" href="#Cluster.Metrics.predict-Union{Tuple{A}, Tuple{Matrix{Float64}, Matrix{Float64}, Dict{Int64, A}}} where A"><code>Cluster.Metrics.predict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict(data, cl_centers, c_num_map; metric=L2])</code></pre><p>This function predicts the attributes from the map <code>c_num_map</code> based from the input data, <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li>data::Matrix{Float64}       – The input data that is compatible with the data used to create the cluster map, <code>cl_centers</code>. See the <code>Input Contract</code> below for details.</li><li>cl_centers::Matrix{Float64} – The geometric centers of the clusters.</li><li>c<em>num</em>map::Dict{Int, A}     – The map from the cluster number to an attribute.</li></ul><p><strong>Optional Arguments</strong></p><ul><li>metric::Function – The metric used to measure the distance between data and cluster centers.</li></ul><p><strong>Input Contract</strong></p><ul><li>|data[:, 1]| = |cl_centers[:, 1]|</li></ul><p><strong>Return</strong></p><p>::Vector{A} – The vector of attribute predictions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/scottrsm/Cluster.jl/blob/bb64a60cb0e93002c56abde1f12c64acc57f7eb7/src/Metrics.jl#L368-L387">source</a></section></article><ul><li><a href="#Cluster.Metrics.CD-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>Cluster.Metrics.CD</code></a></li><li><a href="#Cluster.Metrics.JD-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>Cluster.Metrics.JD</code></a></li><li><a href="#Cluster.Metrics.KL-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>Cluster.Metrics.KL</code></a></li><li><a href="#Cluster.Metrics.L2-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>Cluster.Metrics.L2</code></a></li><li><a href="#Cluster.Metrics.LI-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>Cluster.Metrics.LI</code></a></li><li><a href="#Cluster.Metrics.LP-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64}} where T&lt;:Real"><code>Cluster.Metrics.LP</code></a></li><li><a href="#Cluster.Metrics.confusion_matrix-Union{Tuple{P}, Tuple{A}, Tuple{AbstractVector{A}, AbstractVector{P}}} where {A, P}"><code>Cluster.Metrics.confusion_matrix</code></a></li><li><a href="#Cluster.Metrics.find_cluster_map-Union{Tuple{V}, Tuple{A}, Tuple{AbstractVector{V}, AbstractVector{A}}} where {A, V}"><code>Cluster.Metrics.find_cluster_map</code></a></li><li><a href="#Cluster.Metrics.predict-Union{Tuple{A}, Tuple{Matrix{Float64}, Matrix{Float64}, Dict{Int64, A}}} where A"><code>Cluster.Metrics.predict</code></a></li><li><a href="#Cluster.Metrics.raw_confusion_matrix-Union{Tuple{P}, Tuple{A}, Tuple{AbstractVector{A}, AbstractVector{P}}} where {A, P}"><code>Cluster.Metrics.raw_confusion_matrix</code></a></li><li><a href="#Cluster.find_best_cluster-Union{Tuple{F}, Tuple{T}, Tuple{Matrix{T}, UnitRange{Int64}}} where {T&lt;:AbstractFloat, F&lt;:Function}"><code>Cluster.find_best_cluster</code></a></li><li><a href="#Cluster.find_best_info_for_ks-Union{Tuple{F}, Tuple{T}, Tuple{Matrix{T}, UnitRange{Int64}}} where {T&lt;:AbstractFloat, F&lt;:Function}"><code>Cluster.find_best_info_for_ks</code></a></li><li><a href="#Cluster.kmeans_cluster-Union{Tuple{Matrix{T}}, Tuple{F}, Tuple{T}, Tuple{Matrix{T}, Int64}} where {T&lt;:AbstractFloat, F&lt;:Function}"><code>Cluster.kmeans_cluster</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 8 October 2024 21:33">Tuesday 8 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
